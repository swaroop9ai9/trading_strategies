# -*- coding: utf-8 -*-
"""Arbitrage_Pricing _Theory.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KG58MSI7iMQaWGI071fE8gkgd8KaYVgy
"""

import pandas as pd
import matplotlib.pyplot as plt
import datetime
import seaborn as sns
import warnings
#warnings.filterwarnings(‘ignore’)

from pandas_datareader import data as pdr
!pip3 install yfinance
import yfinance as yf
!pip install fredapi
yf.pdr_override()
from fredapi import Fred

"""# Data Analysis"""

stocks = ['AAPL','MSFT','INTC']
start = datetime.datetime(2010,1,1)
end = datetime.datetime(2019,1,9)
stock_prices = yf.download(stocks,start=start,end = end, interval= '3mo') # We are using quaterly data.
stock_prices.head()

stock_prices=stock_prices['Adj Close']
stock_prices.dropna(inplace=True)
stock_prices.head(10)

# Accordingly, `mean` tells us that stock price of Apple is the highest among 3 companies and, not surprisingly,
# it has the most volatility(High Std dev) indicating that Apple may be the most risky stock.
stock_prices.describe()

fig = plt.figure()
ax1 = fig.add_axes([0.1,0.1,0.8,0.8])
ax1.plot(stock_prices.AAPL,label= 'Apple')
ax1.plot(stock_prices.INTC,label='Intel')
ax1.plot(stock_prices.MSFT,label='Microsoft')
ax1.set_xlabel('Date')
ax1.set_ylabel('Stock Price')
ax1.set_title('Stock Prices')
plt.legend()
plt.show()

returns=stock_prices.pct_change() # Gives the daily returns dataframe after each quater
returns.dropna(inplace=True)
returns.head()

k=1
for i in range(0, len(returns.columns)):
 plt.subplot(3, 1, k)
 plt.hist(returns[returns.columns[i]])
 plt.title('{}'.format(returns.columns[i]))
 k+=1
 plt.tight_layout()
 plt.show()
# These histograms are distribution of returns over the 10 year period. 
# We can see that their are outliers with both 40% return quaterly and -30% return for apple but in lesser volume. Expectation of almost 10percent.
# We can see that INTC is more spread out and varying interns of returns. 
# Microsoft is having majority of data towards right and is left skewed.

# Lets compute correlation analysis Using Heatmap.
heat_corr=returns.corr()
sns.heatmap(heat_corr, annot=True)
plt.title('Correlation Matrix')
plt.show()
# Microsoft and Intel has .66 correlation which is resonable and other stocks are not very much correlated.

"""# Collecting Macroeconomic Variables.
    1) Quarterly GDP per capita growth
    2) Quarterly inflation growth 
    3) quarterly oil price growth.
"""

# We use FredApi (FRED data provided by the Federal Reserve Bank of St. Louis.)
fred = Fred(api_key = '4338b0ca0ecffaafebbd4d161aa8a0cb')

# To find the best-fit risk free rate
fred.search('risk free')

from datetime import datetime
# As a proxy of risk free rate 3-Month Treasury Constant Maturity Rate is used. 
# This rate is widely used in financial analysis as a proxy of risk free rate 
# because government-issued paper is theoretically considered as riskless.
risk_free=fred.get_series('GS3M')
risk_free = risk_free.loc['20100101':'20181201']
rf=risk_free/100

rf.head(5)

# As we previously sampled quaterely, we need to convert the riskfree interest rate also quaterly
rf=rf.resample('Q').mean()*3

plt.plot(risk_free)
plt.xlabel('Date')
plt.ylabel('%')
plt.title('3-Month Treasury Constant Maturity Rate')
# From plot we can observe that, 3-Month Treasury rate was rather stabile roughly during 2010–2015. 
# But from 2017, interest rate was started to raise sharply and reached at 2.5% towards the end of 2018.
# Therefore we obtained the risk-free return on quaterly basis from 2010 to 2018

# GDP factor
gdp=fred.get_series('GDP')
gdp=gdp.loc['20100101':'20181201']
gdp.tail()

# Daily returns of GDP, which indicated the growth
gdp_growth=gdp.pct_change().dropna()

# We can see that GDP growth oscillated between 0.01, indicating the growth is stable and rarely goes below 0.
plt.plot(gdp_growth)
plt.ylabel('GDP Growth Rate')
plt.xlabel('Date')
plt.title('GDP Growth Rate, 2010–2018')

# Calculating Inflation 
fred.search('potential inflation')
inf=fred.get_series('CPIEALL')
inf=inf.loc['20100101':'20181201']
# From data and domain knowledge we know that inflation rate goes up at a moderate pace

print(inf.head())
print(inf.tail())

# For quaterly Sampling rate
inf_quarterly=inf.resample('Q').mean()
inf_growth=inf_quarterly.pct_change().dropna()
inf_growth.head()

# The assertion we made is true, that inflation growth is constant and oscilated every year.
plt.plot(inf_growth)
plt.ylabel('Inflation Growth Rate')
plt.xlabel('Date')
plt.title('Inflation Growth Rate, 2010–2019')

# For importing Oil Price, we can use Quandl API
#!pip install quandl
from datetime import date
import quandl
quandl.ApiConfig.api_key = 'r9xspF46DGBv5sNXdtME'
# Importing our data
oil = quandl.get("ODA/POILBRE_USD", start_date="2009-12-01", end_date="2019-01-01")
# Resampling for monthly
oil_quarterly=oil.resample('Q').mean()

plt.plot(oil_quarterly)
plt.ylabel('Oil Price Quaterly')
plt.xlabel('Date')
plt.title('Oil Price from, 2010–2019')
# Oil price shows considerable instability. Oil price, for instance, has its peak at 118 USD in 2012 but it plunged and 
# dropped to 34 USD in 2016 following the short-term restriction on oil supply. As is seen, there exists wild volatility 
# in the oil price in this study period.

# Inorder to check the daily returns in Oil price.
oil_return=oil_quarterly.pct_change().dropna()
oil_return.head()

# High volatility in oil price can be observed simply by looking at the oil return during 2010–2018.
plt.plot(oil_return)
plt.ylabel('Oil Quaterly Returns')
plt.xlabel('Date')
plt.title('Oil Quaterly Returns from, 2010–2019')
# The most striking observation is oil price dropped and increase by nearly 30% in mid-2015 and mid-2016, respectively.

"""# Data Cleaning for APT Implementation"""

# Data Preparation to fit all data in one dataframe
returns=returns.reset_index() # Original Stock Portfolio Dataframe
returns.drop('Date',axis=1,inplace=True)

# Manipulation on Risk Free Dataframe
rf=pd.DataFrame(rf)
rf=rf.reset_index() # Ignoring Index
rf.drop('index',axis=1,inplace=True) # Dropping Index Column
rf.columns=['rf']
returns['rf']=pd.DataFrame(rf) # Adding the riskfree return series to returns dataframe

# We are subtracting the excess return ie risk free return if invested on govt currency for each stock.
stocks=['AAPL','INTC','MSFT']
for i in stocks:
 returns['excess_return_'+str(i)]=returns[i]-returns.rf # Adding the columns after subtracting risk free return

returns.head(5)

# We apply the same treatment for other macroeconomic variables as well.
gdp_growth=gdp_growth.reset_index()
inf_growth=inf_growth.reset_index()
oil_return=oil_return.reset_index()
gdp_growth.drop('index',axis=1,inplace=True)
inf_growth.drop('index',axis=1,inplace=True)
oil_return.drop('Date',axis=1,inplace=True)
gdp_growth.columns=["gdp_growth"]
inf_growth.columns=["inf_growth"]
oil_return.columns=["oil_return"]

# Let us examine each of the stocks seperatly with macroeconomic variables
data1=pd.concat([gdp_growth, inf_growth,oil_return], axis=1)
data2=pd.concat([gdp_growth, inf_growth,oil_return], axis=1)
data3=pd.concat([gdp_growth, inf_growth,oil_return], axis=1)

# Three different data which is labeled as “data1”,”data2", and “data3”. Macroeconomic variables are the same in all data.
# The only difference is the stocks, That is to say, “data1” includes excess return of Apple,
#  “data2” includes excess return of Intel, “data3” includes excess return of Microsoft.
data1['excess_return']=returns.excess_return_AAPL
data2['excess_return']=returns.excess_return_INTC
data3['excess_return']=returns.excess_return_MSFT

# empirically test the validity of APT by simply using some main US macroeconomic variables.
# Lets see if we can fit an Regression line for the data
import statsmodels.regression.linear_model as smlr
models =[]
for i in (data1,data2,data3):
    formula =  "excess_return~ gdp_growth+inf_growth+oil_return"
    models.append(smlr.OLS.from_formula(formula, data = i).fit())

# The result shows the association between excess return of Apple and pre-defined macroeconomic variables. 
# Accordingly, the estimated coefficient of the model is not statistically significant indicating that 
# these macroeconomic variables do not account for the excess return of Apple. More specifically, 
# by looking at p-values, I conclude that the estimated coefficients of  inflation growth, and 
# oil return is not statistically significant at conventional levels.
# But GDP is having a part in prediction of AAPL stock Price
# To be interpret, one unit increase in gdp growth boosts excess return in apple by nearly 11.4 times.
models[0].summary()

# This model presents the nexus between excess return of Intel and the same macroecomic variables provided below.
#  Differently from the Apple case, this analysis confirms that there is a statistically significant relationship between excess return
# of Intel and gdp growth of US at 10% level (p-value is 0.093). To be interpret, one unit increase in gdp growth boosts
# excess return on Intel by nearly 8.96. So, there is a positive relationship between gdp growth and excess return of Intel. 
# However, no relation is detected for the rest of the variables.
models[1].summary()

# Microsoft is not having not much of influence on Stock price by macro economic factors.
models[2].summary()

